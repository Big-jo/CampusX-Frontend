{"version":3,"sources":["webpack:///node_modules/plyr/src/js/plyr.js"],"names":["captions","defaults","pip","getProviderByUrl","providers","types","Console","controls","Fullscreen","Listeners","media","Ads","PreviewThumbnails","source","Storage","support","ui","closest","createElement","hasClass","removeElement","replaceElement","toggleClass","wrap","off","on","once","triggerEvent","unbindListeners","is","loadSprite","clamp","cloneDeep","extend","getAspectRatio","reduceAspectRatio","setAspectRatio","validateRatio","parseUrl","Plyr","[object Object]","target","options","this","timers","ready","loading","failed","touch","string","document","querySelectorAll","window","jQuery","nodeList","array","config","JSON","parse","getAttribute","e","elements","container","buttons","display","progress","inputs","settings","popup","menu","panels","active","currentTrack","meta","WeakMap","fullscreen","speed","quality","debug","log","nullOrUndefined","element","error","plyr","warn","enabled","check","api","clone","cloneNode","autoplay","original","type","tagName","toLowerCase","iframe","url","querySelector","provider","toString","className","search","length","truthy","includes","searchParams","get","loop","isYouTube","playsinline","youtube","hl","attributes","embed","removeAttribute","empty","Object","keys","video","html5","hasAttribute","crossorigin","muted","supported","eventListeners","listeners","storage","tabindex","addStyleHook","call","setup","events","join","event","isHTML5","isEmbed","build","global","ads","setTimeout","play","lastSeekTime","previewThumbnails","isVimeo","vimeo","isVideo","isAudio","audio","function","managerPromise","then","catch","playing","pause","Boolean","paused","ended","stopped","currentTime","input","boolean","restart","stop","seekTime","number","duration","inputIsValid","Math","min","Number","buffered","end","seeking","fauxDuration","parseFloat","realDuration","Infinity","volume","value","step","increaseVolume","mute","toggle","hasAudio","mozHasAudio","webkitAudioDecodedByteCount","audioTracks","selected","minimumSpeed","maximumSpeed","max","playbackRate","default","find","updateStorage","set","change","currentSrc","download","urls","setDownloadUrl","poster","setPoster","ratio","toggled","language","setLanguage","getCurrentTrack","webkitSetPresentationMode","inactive","requestPictureInPicture","exitPictureInPicture","webkitPresentationMode","pictureInPictureElement","airplay","webkitShowPlaybackTargetPicker","isHidden","classNames","hideControls","hiding","undefined","toggleMenu","callback","soft","done","body","style","overflow","wrapper","clearTimeout","resized","toggleNativeControls","clearInterval","buffering","destroy","unload","mime","inline","id","selector","targets","Array","from","filter","map","t"],"mappings":"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","file":"scripts.2ba6eb1d242923a248b6.js","sourcesContent":["// ==========================================================================\n// Plyr\n// plyr.js v3.5.6\n// https://github.com/sampotts/plyr\n// License: The MIT License (MIT)\n// ==========================================================================\n\nimport captions from './captions';\nimport defaults from './config/defaults';\nimport { pip } from './config/states';\nimport { getProviderByUrl, providers, types } from './config/types';\nimport Console from './console';\nimport controls from './controls';\nimport Fullscreen from './fullscreen';\nimport Listeners from './listeners';\nimport media from './media';\nimport Ads from './plugins/ads';\nimport PreviewThumbnails from './plugins/preview-thumbnails';\nimport source from './source';\nimport Storage from './storage';\nimport support from './support';\nimport ui from './ui';\nimport { closest } from './utils/arrays';\nimport { createElement, hasClass, removeElement, replaceElement, toggleClass, wrap } from './utils/elements';\nimport { off, on, once, triggerEvent, unbindListeners } from './utils/events';\nimport is from './utils/is';\nimport loadSprite from './utils/load-sprite';\nimport { clamp } from './utils/numbers';\nimport { cloneDeep, extend } from './utils/objects';\nimport { getAspectRatio, reduceAspectRatio, setAspectRatio, validateRatio } from './utils/style';\nimport { parseUrl } from './utils/urls';\n\n// Private properties\n// TODO: Use a WeakMap for private globals\n// const globals = new WeakMap();\n\n// Plyr instance\nclass Plyr {\n    constructor(target, options) {\n        this.timers = {};\n\n        // State\n        this.ready = false;\n        this.loading = false;\n        this.failed = false;\n\n        // Touch device\n        this.touch = support.touch;\n\n        // Set the media element\n        this.media = target;\n\n        // String selector passed\n        if (is.string(this.media)) {\n            this.media = document.querySelectorAll(this.media);\n        }\n\n        // jQuery, NodeList or Array passed, use first element\n        if ((window.jQuery && this.media instanceof jQuery) || is.nodeList(this.media) || is.array(this.media)) {\n            // eslint-disable-next-line\n            this.media = this.media[0];\n        }\n\n        // Set config\n        this.config = extend(\n            {},\n            defaults,\n            Plyr.defaults,\n            options || {},\n            (() => {\n                try {\n                    return JSON.parse(this.media.getAttribute('data-plyr-config'));\n                } catch (e) {\n                    return {};\n                }\n            })()\n        );\n\n        // Elements cache\n        this.elements = {\n            container: null,\n            captions: null,\n            buttons: {},\n            display: {},\n            progress: {},\n            inputs: {},\n            settings: {\n                popup: null,\n                menu: null,\n                panels: {},\n                buttons: {},\n            },\n        };\n\n        // Captions\n        this.captions = {\n            active: null,\n            currentTrack: -1,\n            meta: new WeakMap(),\n        };\n\n        // Fullscreen\n        this.fullscreen = {\n            active: false,\n        };\n\n        // Options\n        this.options = {\n            speed: [],\n            quality: [],\n        };\n\n        // Debugging\n        // TODO: move to globals\n        this.debug = new Console(this.config.debug);\n\n        // Log config options and support\n        this.debug.log('Config', this.config);\n        this.debug.log('Support', support);\n\n        // We need an element to setup\n        if (is.nullOrUndefined(this.media) || !is.element(this.media)) {\n            this.debug.error('Setup failed: no suitable element passed');\n            return;\n        }\n\n        // Bail if the element is initialized\n        if (this.media.plyr) {\n            this.debug.warn('Target already setup');\n            return;\n        }\n\n        // Bail if not enabled\n        if (!this.config.enabled) {\n            this.debug.error('Setup failed: disabled by config');\n            return;\n        }\n\n        // Bail if disabled or no basic support\n        // You may want to disable certain UAs etc\n        if (!support.check().api) {\n            this.debug.error('Setup failed: no support');\n            return;\n        }\n\n        // Cache original element state for .destroy()\n        const clone = this.media.cloneNode(true);\n        clone.autoplay = false;\n        this.elements.original = clone;\n\n        // Set media type based on tag or data attribute\n        // Supported: video, audio, vimeo, youtube\n        const type = this.media.tagName.toLowerCase();\n        // Embed properties\n        let iframe = null;\n        let url = null;\n\n        // Different setup based on type\n        switch (type) {\n            case 'div':\n                // Find the frame\n                iframe = this.media.querySelector('iframe');\n\n                // <iframe> type\n                if (is.element(iframe)) {\n                    // Detect provider\n                    url = parseUrl(iframe.getAttribute('src'));\n                    this.provider = getProviderByUrl(url.toString());\n\n                    // Rework elements\n                    this.elements.container = this.media;\n                    this.media = iframe;\n\n                    // Reset classname\n                    this.elements.container.className = '';\n\n                    // Get attributes from URL and set config\n                    if (url.search.length) {\n                        const truthy = ['1', 'true'];\n\n                        if (truthy.includes(url.searchParams.get('autoplay'))) {\n                            this.config.autoplay = true;\n                        }\n                        if (truthy.includes(url.searchParams.get('loop'))) {\n                            this.config.loop.active = true;\n                        }\n\n                        // TODO: replace fullscreen.iosNative with this playsinline config option\n                        // YouTube requires the playsinline in the URL\n                        if (this.isYouTube) {\n                            this.config.playsinline = truthy.includes(url.searchParams.get('playsinline'));\n                            this.config.youtube.hl = url.searchParams.get('hl'); // TODO: Should this be setting language?\n                        } else {\n                            this.config.playsinline = true;\n                        }\n                    }\n                } else {\n                    // <div> with attributes\n                    this.provider = this.media.getAttribute(this.config.attributes.embed.provider);\n\n                    // Remove attribute\n                    this.media.removeAttribute(this.config.attributes.embed.provider);\n                }\n\n                // Unsupported or missing provider\n                if (is.empty(this.provider) || !Object.keys(providers).includes(this.provider)) {\n                    this.debug.error('Setup failed: Invalid provider');\n                    return;\n                }\n\n                // Audio will come later for external providers\n                this.type = types.video;\n\n                break;\n\n            case 'video':\n            case 'audio':\n                this.type = type;\n                this.provider = providers.html5;\n\n                // Get config from attributes\n                if (this.media.hasAttribute('crossorigin')) {\n                    this.config.crossorigin = true;\n                }\n                if (this.media.hasAttribute('autoplay')) {\n                    this.config.autoplay = true;\n                }\n                if (this.media.hasAttribute('playsinline') || this.media.hasAttribute('webkit-playsinline')) {\n                    this.config.playsinline = true;\n                }\n                if (this.media.hasAttribute('muted')) {\n                    this.config.muted = true;\n                }\n                if (this.media.hasAttribute('loop')) {\n                    this.config.loop.active = true;\n                }\n\n                break;\n\n            default:\n                this.debug.error('Setup failed: unsupported type');\n                return;\n        }\n\n        // Check for support again but with type\n        this.supported = support.check(this.type, this.provider, this.config.playsinline);\n\n        // If no support for even API, bail\n        if (!this.supported.api) {\n            this.debug.error('Setup failed: no support');\n            return;\n        }\n\n        this.eventListeners = [];\n\n        // Create listeners\n        this.listeners = new Listeners(this);\n\n        // Setup local storage for user settings\n        this.storage = new Storage(this);\n\n        // Store reference\n        this.media.plyr = this;\n\n        // Wrap media\n        if (!is.element(this.elements.container)) {\n            this.elements.container = createElement('div', { tabindex: 0 });\n            wrap(this.media, this.elements.container);\n        }\n\n        // Add style hook\n        ui.addStyleHook.call(this);\n\n        // Setup media\n        media.setup.call(this);\n\n        // Listen for events if debugging\n        if (this.config.debug) {\n            on.call(this, this.elements.container, this.config.events.join(' '), event => {\n                this.debug.log(`event: ${event.type}`);\n            });\n        }\n\n        // Setup interface\n        // If embed but not fully supported, build interface now to avoid flash of controls\n        if (this.isHTML5 || (this.isEmbed && !this.supported.ui)) {\n            ui.build.call(this);\n        }\n\n        // Container listeners\n        this.listeners.container();\n\n        // Global listeners\n        this.listeners.global();\n\n        // Setup fullscreen\n        this.fullscreen = new Fullscreen(this);\n\n        // Setup ads if provided\n        if (this.config.ads.enabled) {\n            this.ads = new Ads(this);\n        }\n\n        // Autoplay if required\n        if (this.isHTML5 && this.config.autoplay) {\n            setTimeout(() => this.play(), 10);\n        }\n\n        // Seek time will be recorded (in listeners.js) so we can prevent hiding controls for a few seconds after seek\n        this.lastSeekTime = 0;\n\n        // Setup preview thumbnails if enabled\n        if (this.config.previewThumbnails.enabled) {\n            this.previewThumbnails = new PreviewThumbnails(this);\n        }\n    }\n\n    // ---------------------------------------\n    // API\n    // ---------------------------------------\n\n    /**\n     * Types and provider helpers\n     */\n    get isHTML5() {\n        return this.provider === providers.html5;\n    }\n\n    get isEmbed() {\n        return this.isYouTube || this.isVimeo;\n    }\n\n    get isYouTube() {\n        return this.provider === providers.youtube;\n    }\n\n    get isVimeo() {\n        return this.provider === providers.vimeo;\n    }\n\n    get isVideo() {\n        return this.type === types.video;\n    }\n\n    get isAudio() {\n        return this.type === types.audio;\n    }\n\n    /**\n     * Play the media, or play the advertisement (if they are not blocked)\n     */\n    play() {\n        if (!is.function(this.media.play)) {\n            return null;\n        }\n\n        // Intecept play with ads\n        if (this.ads && this.ads.enabled) {\n            this.ads.managerPromise.then(() => this.ads.play()).catch(() => this.media.play());\n        }\n\n        // Return the promise (for HTML5)\n        return this.media.play();\n    }\n\n    /**\n     * Pause the media\n     */\n    pause() {\n        if (!this.playing || !is.function(this.media.pause)) {\n            return;\n        }\n\n        this.media.pause();\n    }\n\n    /**\n     * Get playing state\n     */\n    get playing() {\n        return Boolean(this.ready && !this.paused && !this.ended);\n    }\n\n    /**\n     * Get paused state\n     */\n    get paused() {\n        return Boolean(this.media.paused);\n    }\n\n    /**\n     * Get stopped state\n     */\n    get stopped() {\n        return Boolean(this.paused && this.currentTime === 0);\n    }\n\n    /**\n     * Get ended state\n     */\n    get ended() {\n        return Boolean(this.media.ended);\n    }\n\n    /**\n     * Toggle playback based on current status\n     * @param {Boolean} input\n     */\n    togglePlay(input) {\n        // Toggle based on current state if nothing passed\n        const toggle = is.boolean(input) ? input : !this.playing;\n\n        if (toggle) {\n            this.play();\n        } else {\n            this.pause();\n        }\n    }\n\n    /**\n     * Stop playback\n     */\n    stop() {\n        if (this.isHTML5) {\n            this.pause();\n            this.restart();\n        } else if (is.function(this.media.stop)) {\n            this.media.stop();\n        }\n    }\n\n    /**\n     * Restart playback\n     */\n    restart() {\n        this.currentTime = 0;\n    }\n\n    /**\n     * Rewind\n     * @param {Number} seekTime - how far to rewind in seconds. Defaults to the config.seekTime\n     */\n    rewind(seekTime) {\n        this.currentTime = this.currentTime - (is.number(seekTime) ? seekTime : this.config.seekTime);\n    }\n\n    /**\n     * Fast forward\n     * @param {Number} seekTime - how far to fast forward in seconds. Defaults to the config.seekTime\n     */\n    forward(seekTime) {\n        this.currentTime = this.currentTime + (is.number(seekTime) ? seekTime : this.config.seekTime);\n    }\n\n    /**\n     * Seek to a time\n     * @param {Number} input - where to seek to in seconds. Defaults to 0 (the start)\n     */\n    set currentTime(input) {\n        // Bail if media duration isn't available yet\n        if (!this.duration) {\n            return;\n        }\n\n        // Validate input\n        const inputIsValid = is.number(input) && input > 0;\n\n        // Set\n        this.media.currentTime = inputIsValid ? Math.min(input, this.duration) : 0;\n\n        // Logging\n        this.debug.log(`Seeking to ${this.currentTime} seconds`);\n    }\n\n    /**\n     * Get current time\n     */\n    get currentTime() {\n        return Number(this.media.currentTime);\n    }\n\n    /**\n     * Get buffered\n     */\n    get buffered() {\n        const { buffered } = this.media;\n\n        // YouTube / Vimeo return a float between 0-1\n        if (is.number(buffered)) {\n            return buffered;\n        }\n\n        // HTML5\n        // TODO: Handle buffered chunks of the media\n        // (i.e. seek to another section buffers only that section)\n        if (buffered && buffered.length && this.duration > 0) {\n            return buffered.end(0) / this.duration;\n        }\n\n        return 0;\n    }\n\n    /**\n     * Get seeking status\n     */\n    get seeking() {\n        return Boolean(this.media.seeking);\n    }\n\n    /**\n     * Get the duration of the current media\n     */\n    get duration() {\n        // Faux duration set via config\n        const fauxDuration = parseFloat(this.config.duration);\n        // Media duration can be NaN or Infinity before the media has loaded\n        const realDuration = (this.media || {}).duration;\n        const duration = !is.number(realDuration) || realDuration === Infinity ? 0 : realDuration;\n\n        // If config duration is funky, use regular duration\n        return fauxDuration || duration;\n    }\n\n    /**\n     * Set the player volume\n     * @param {Number} value - must be between 0 and 1. Defaults to the value from local storage and config.volume if not set in storage\n     */\n    set volume(value) {\n        let volume = value;\n        const max = 1;\n        const min = 0;\n\n        if (is.string(volume)) {\n            volume = Number(volume);\n        }\n\n        // Load volume from storage if no value specified\n        if (!is.number(volume)) {\n            volume = this.storage.get('volume');\n        }\n\n        // Use config if all else fails\n        if (!is.number(volume)) {\n            ({ volume } = this.config);\n        }\n\n        // Maximum is volumeMax\n        if (volume > max) {\n            volume = max;\n        }\n        // Minimum is volumeMin\n        if (volume < min) {\n            volume = min;\n        }\n\n        // Update config\n        this.config.volume = volume;\n\n        // Set the player volume\n        this.media.volume = volume;\n\n        // If muted, and we're increasing volume manually, reset muted state\n        if (!is.empty(value) && this.muted && volume > 0) {\n            this.muted = false;\n        }\n    }\n\n    /**\n     * Get the current player volume\n     */\n    get volume() {\n        return Number(this.media.volume);\n    }\n\n    /**\n     * Increase volume\n     * @param {Boolean} step - How much to decrease by (between 0 and 1)\n     */\n    increaseVolume(step) {\n        const volume = this.media.muted ? 0 : this.volume;\n        this.volume = volume + (is.number(step) ? step : 0);\n    }\n\n    /**\n     * Decrease volume\n     * @param {Boolean} step - How much to decrease by (between 0 and 1)\n     */\n    decreaseVolume(step) {\n        this.increaseVolume(-step);\n    }\n\n    /**\n     * Set muted state\n     * @param {Boolean} mute\n     */\n    set muted(mute) {\n        let toggle = mute;\n\n        // Load muted state from storage\n        if (!is.boolean(toggle)) {\n            toggle = this.storage.get('muted');\n        }\n\n        // Use config if all else fails\n        if (!is.boolean(toggle)) {\n            toggle = this.config.muted;\n        }\n\n        // Update config\n        this.config.muted = toggle;\n\n        // Set mute on the player\n        this.media.muted = toggle;\n    }\n\n    /**\n     * Get current muted state\n     */\n    get muted() {\n        return Boolean(this.media.muted);\n    }\n\n    /**\n     * Check if the media has audio\n     */\n    get hasAudio() {\n        // Assume yes for all non HTML5 (as we can't tell...)\n        if (!this.isHTML5) {\n            return true;\n        }\n\n        if (this.isAudio) {\n            return true;\n        }\n\n        // Get audio tracks\n        return (\n            Boolean(this.media.mozHasAudio) ||\n            Boolean(this.media.webkitAudioDecodedByteCount) ||\n            Boolean(this.media.audioTracks && this.media.audioTracks.length)\n        );\n    }\n\n    /**\n     * Set playback speed\n     * @param {Number} speed - the speed of playback (0.5-2.0)\n     */\n    set speed(input) {\n        let speed = null;\n\n        if (is.number(input)) {\n            speed = input;\n        }\n\n        if (!is.number(speed)) {\n            speed = this.storage.get('speed');\n        }\n\n        if (!is.number(speed)) {\n            speed = this.config.speed.selected;\n        }\n\n        // Clamp to min/max\n        const { minimumSpeed: min, maximumSpeed: max } = this;\n        speed = clamp(speed, min, max);\n\n        // Update config\n        this.config.speed.selected = speed;\n\n        // Set media speed\n        setTimeout(() => {\n            this.media.playbackRate = speed;\n        }, 0);\n    }\n\n    /**\n     * Get current playback speed\n     */\n    get speed() {\n        return Number(this.media.playbackRate);\n    }\n\n    /**\n     * Get the minimum allowed speed\n     */\n    get minimumSpeed() {\n        if (this.isYouTube) {\n            // https://developers.google.com/youtube/iframe_api_reference#setPlaybackRate\n            return Math.min(...this.options.speed);\n        }\n\n        if (this.isVimeo) {\n            // https://github.com/vimeo/player.js/#setplaybackrateplaybackrate-number-promisenumber-rangeerrorerror\n            return 0.5;\n        }\n\n        // https://stackoverflow.com/a/32320020/1191319\n        return 0.0625;\n    }\n\n    /**\n     * Get the maximum allowed speed\n     */\n    get maximumSpeed() {\n        if (this.isYouTube) {\n            // https://developers.google.com/youtube/iframe_api_reference#setPlaybackRate\n            return Math.max(...this.options.speed);\n        }\n\n        if (this.isVimeo) {\n            // https://github.com/vimeo/player.js/#setplaybackrateplaybackrate-number-promisenumber-rangeerrorerror\n            return 2;\n        }\n\n        // https://stackoverflow.com/a/32320020/1191319\n        return 16;\n    }\n\n    /**\n     * Set playback quality\n     * Currently HTML5 & YouTube only\n     * @param {Number} input - Quality level\n     */\n    set quality(input) {\n        const config = this.config.quality;\n        const options = this.options.quality;\n\n        if (!options.length) {\n            return;\n        }\n\n        let quality = [\n            !is.empty(input) && Number(input),\n            this.storage.get('quality'),\n            config.selected,\n            config.default,\n        ].find(is.number);\n\n        let updateStorage = true;\n\n        if (!options.includes(quality)) {\n            const value = closest(options, quality);\n            this.debug.warn(`Unsupported quality option: ${quality}, using ${value} instead`);\n            quality = value;\n\n            // Don't update storage if quality is not supported\n            updateStorage = false;\n        }\n\n        // Update config\n        config.selected = quality;\n\n        // Set quality\n        this.media.quality = quality;\n\n        // Save to storage\n        if (updateStorage) {\n            this.storage.set({ quality });\n        }\n    }\n\n    /**\n     * Get current quality level\n     */\n    get quality() {\n        return this.media.quality;\n    }\n\n    /**\n     * Toggle loop\n     * TODO: Finish fancy new logic. Set the indicator on load as user may pass loop as config\n     * @param {Boolean} input - Whether to loop or not\n     */\n    set loop(input) {\n        const toggle = is.boolean(input) ? input : this.config.loop.active;\n        this.config.loop.active = toggle;\n        this.media.loop = toggle;\n\n        // Set default to be a true toggle\n        /* const type = ['start', 'end', 'all', 'none', 'toggle'].includes(input) ? input : 'toggle';\n\n        switch (type) {\n            case 'start':\n                if (this.config.loop.end && this.config.loop.end <= this.currentTime) {\n                    this.config.loop.end = null;\n                }\n                this.config.loop.start = this.currentTime;\n                // this.config.loop.indicator.start = this.elements.display.played.value;\n                break;\n\n            case 'end':\n                if (this.config.loop.start >= this.currentTime) {\n                    return this;\n                }\n                this.config.loop.end = this.currentTime;\n                // this.config.loop.indicator.end = this.elements.display.played.value;\n                break;\n\n            case 'all':\n                this.config.loop.start = 0;\n                this.config.loop.end = this.duration - 2;\n                this.config.loop.indicator.start = 0;\n                this.config.loop.indicator.end = 100;\n                break;\n\n            case 'toggle':\n                if (this.config.loop.active) {\n                    this.config.loop.start = 0;\n                    this.config.loop.end = null;\n                } else {\n                    this.config.loop.start = 0;\n                    this.config.loop.end = this.duration - 2;\n                }\n                break;\n\n            default:\n                this.config.loop.start = 0;\n                this.config.loop.end = null;\n                break;\n        } */\n    }\n\n    /**\n     * Get current loop state\n     */\n    get loop() {\n        return Boolean(this.media.loop);\n    }\n\n    /**\n     * Set new media source\n     * @param {Object} input - The new source object (see docs)\n     */\n    set source(input) {\n        source.change.call(this, input);\n    }\n\n    /**\n     * Get current source\n     */\n    get source() {\n        return this.media.currentSrc;\n    }\n\n    /**\n     * Get a download URL (either source or custom)\n     */\n    get download() {\n        const { download } = this.config.urls;\n\n        return is.url(download) ? download : this.source;\n    }\n\n    /**\n     * Set the download URL\n     */\n    set download(input) {\n        if (!is.url(input)) {\n            return;\n        }\n\n        this.config.urls.download = input;\n\n        controls.setDownloadUrl.call(this);\n    }\n\n    /**\n     * Set the poster image for a video\n     * @param {String} input - the URL for the new poster image\n     */\n    set poster(input) {\n        if (!this.isVideo) {\n            this.debug.warn('Poster can only be set for video');\n            return;\n        }\n\n        ui.setPoster.call(this, input, false).catch(() => {});\n    }\n\n    /**\n     * Get the current poster image\n     */\n    get poster() {\n        if (!this.isVideo) {\n            return null;\n        }\n\n        return this.media.getAttribute('poster');\n    }\n\n    /**\n     * Get the current aspect ratio in use\n     */\n    get ratio() {\n        if (!this.isVideo) {\n            return null;\n        }\n\n        const ratio = reduceAspectRatio(getAspectRatio.call(this));\n\n        return is.array(ratio) ? ratio.join(':') : ratio;\n    }\n\n    /**\n     * Set video aspect ratio\n     */\n    set ratio(input) {\n        if (!this.isVideo) {\n            this.debug.warn('Aspect ratio can only be set for video');\n            return;\n        }\n\n        if (!is.string(input) || !validateRatio(input)) {\n            this.debug.error(`Invalid aspect ratio specified (${input})`);\n            return;\n        }\n\n        this.config.ratio = input;\n\n        setAspectRatio.call(this);\n    }\n\n    /**\n     * Set the autoplay state\n     * @param {Boolean} input - Whether to autoplay or not\n     */\n    set autoplay(input) {\n        const toggle = is.boolean(input) ? input : this.config.autoplay;\n        this.config.autoplay = toggle;\n    }\n\n    /**\n     * Get the current autoplay state\n     */\n    get autoplay() {\n        return Boolean(this.config.autoplay);\n    }\n\n    /**\n     * Toggle captions\n     * @param {Boolean} input - Whether to enable captions\n     */\n    toggleCaptions(input) {\n        captions.toggle.call(this, input, false);\n    }\n\n    /**\n     * Set the caption track by index\n     * @param {Number} - Caption index\n     */\n    set currentTrack(input) {\n        captions.set.call(this, input, false);\n    }\n\n    /**\n     * Get the current caption track index (-1 if disabled)\n     */\n    get currentTrack() {\n        const { toggled, currentTrack } = this.captions;\n        return toggled ? currentTrack : -1;\n    }\n\n    /**\n     * Set the wanted language for captions\n     * Since tracks can be added later it won't update the actual caption track until there is a matching track\n     * @param {String} - Two character ISO language code (e.g. EN, FR, PT, etc)\n     */\n    set language(input) {\n        captions.setLanguage.call(this, input, false);\n    }\n\n    /**\n     * Get the current track's language\n     */\n    get language() {\n        return (captions.getCurrentTrack.call(this) || {}).language;\n    }\n\n    /**\n     * Toggle picture-in-picture playback on WebKit/MacOS\n     * TODO: update player with state, support, enabled\n     * TODO: detect outside changes\n     */\n    set pip(input) {\n        // Bail if no support\n        if (!support.pip) {\n            return;\n        }\n\n        // Toggle based on current state if not passed\n        const toggle = is.boolean(input) ? input : !this.pip;\n\n        // Toggle based on current state\n        // Safari\n        if (is.function(this.media.webkitSetPresentationMode)) {\n            this.media.webkitSetPresentationMode(toggle ? pip.active : pip.inactive);\n        }\n\n        // Chrome\n        if (is.function(this.media.requestPictureInPicture)) {\n            if (!this.pip && toggle) {\n                this.media.requestPictureInPicture();\n            } else if (this.pip && !toggle) {\n                document.exitPictureInPicture();\n            }\n        }\n    }\n\n    /**\n     * Get the current picture-in-picture state\n     */\n    get pip() {\n        if (!support.pip) {\n            return null;\n        }\n\n        // Safari\n        if (!is.empty(this.media.webkitPresentationMode)) {\n            return this.media.webkitPresentationMode === pip.active;\n        }\n\n        // Chrome\n        return this.media === document.pictureInPictureElement;\n    }\n\n    /**\n     * Trigger the airplay dialog\n     * TODO: update player with state, support, enabled\n     */\n    airplay() {\n        // Show dialog if supported\n        if (support.airplay) {\n            this.media.webkitShowPlaybackTargetPicker();\n        }\n    }\n\n    /**\n     * Toggle the player controls\n     * @param {Boolean} [toggle] - Whether to show the controls\n     */\n    toggleControls(toggle) {\n        // Don't toggle if missing UI support or if it's audio\n        if (this.supported.ui && !this.isAudio) {\n            // Get state before change\n            const isHidden = hasClass(this.elements.container, this.config.classNames.hideControls);\n            // Negate the argument if not undefined since adding the class to hides the controls\n            const force = typeof toggle === 'undefined' ? undefined : !toggle;\n            // Apply and get updated state\n            const hiding = toggleClass(this.elements.container, this.config.classNames.hideControls, force);\n\n            // Close menu\n            if (hiding && this.config.controls.includes('settings') && !is.empty(this.config.settings)) {\n                controls.toggleMenu.call(this, false);\n            }\n\n            // Trigger event on change\n            if (hiding !== isHidden) {\n                const eventName = hiding ? 'controlshidden' : 'controlsshown';\n                triggerEvent.call(this, this.media, eventName);\n            }\n\n            return !hiding;\n        }\n\n        return false;\n    }\n\n    /**\n     * Add event listeners\n     * @param {String} event - Event type\n     * @param {Function} callback - Callback for when event occurs\n     */\n    on(event, callback) {\n        on.call(this, this.elements.container, event, callback);\n    }\n\n    /**\n     * Add event listeners once\n     * @param {String} event - Event type\n     * @param {Function} callback - Callback for when event occurs\n     */\n    once(event, callback) {\n        once.call(this, this.elements.container, event, callback);\n    }\n\n    /**\n     * Remove event listeners\n     * @param {String} event - Event type\n     * @param {Function} callback - Callback for when event occurs\n     */\n    off(event, callback) {\n        off(this.elements.container, event, callback);\n    }\n\n    /**\n     * Destroy an instance\n     * Event listeners are removed when elements are removed\n     * http://stackoverflow.com/questions/12528049/if-a-dom-element-is-removed-are-its-listeners-also-removed-from-memory\n     * @param {Function} callback - Callback for when destroy is complete\n     * @param {Boolean} soft - Whether it's a soft destroy (for source changes etc)\n     */\n    destroy(callback, soft = false) {\n        if (!this.ready) {\n            return;\n        }\n\n        const done = () => {\n            // Reset overflow (incase destroyed while in fullscreen)\n            document.body.style.overflow = '';\n\n            // GC for embed\n            this.embed = null;\n\n            // If it's a soft destroy, make minimal changes\n            if (soft) {\n                if (Object.keys(this.elements).length) {\n                    // Remove elements\n                    removeElement(this.elements.buttons.play);\n                    removeElement(this.elements.captions);\n                    removeElement(this.elements.controls);\n                    removeElement(this.elements.wrapper);\n\n                    // Clear for GC\n                    this.elements.buttons.play = null;\n                    this.elements.captions = null;\n                    this.elements.controls = null;\n                    this.elements.wrapper = null;\n                }\n\n                // Callback\n                if (is.function(callback)) {\n                    callback();\n                }\n            } else {\n                // Unbind listeners\n                unbindListeners.call(this);\n\n                // Replace the container with the original element provided\n                replaceElement(this.elements.original, this.elements.container);\n\n                // Event\n                triggerEvent.call(this, this.elements.original, 'destroyed', true);\n\n                // Callback\n                if (is.function(callback)) {\n                    callback.call(this.elements.original);\n                }\n\n                // Reset state\n                this.ready = false;\n\n                // Clear for garbage collection\n                setTimeout(() => {\n                    this.elements = null;\n                    this.media = null;\n                }, 200);\n            }\n        };\n\n        // Stop playback\n        this.stop();\n\n        // Clear timeouts\n        clearTimeout(this.timers.loading);\n        clearTimeout(this.timers.controls);\n        clearTimeout(this.timers.resized);\n\n        // Provider specific stuff\n        if (this.isHTML5) {\n            // Restore native video controls\n            ui.toggleNativeControls.call(this, true);\n\n            // Clean up\n            done();\n        } else if (this.isYouTube) {\n            // Clear timers\n            clearInterval(this.timers.buffering);\n            clearInterval(this.timers.playing);\n\n            // Destroy YouTube API\n            if (this.embed !== null && is.function(this.embed.destroy)) {\n                this.embed.destroy();\n            }\n\n            // Clean up\n            done();\n        } else if (this.isVimeo) {\n            // Destroy Vimeo API\n            // then clean up (wait, to prevent postmessage errors)\n            if (this.embed !== null) {\n                this.embed.unload().then(done);\n            }\n\n            // Vimeo does not always return\n            setTimeout(done, 200);\n        }\n    }\n\n    /**\n     * Check for support for a mime type (HTML5 only)\n     * @param {String} type - Mime type\n     */\n    supports(type) {\n        return support.mime.call(this, type);\n    }\n\n    /**\n     * Check for support\n     * @param {String} type - Player type (audio/video)\n     * @param {String} provider - Provider (html5/youtube/vimeo)\n     * @param {Boolean} inline - Where player has `playsinline` sttribute\n     */\n    static supported(type, provider, inline) {\n        return support.check(type, provider, inline);\n    }\n\n    /**\n     * Load an SVG sprite into the page\n     * @param {String} url - URL for the SVG sprite\n     * @param {String} [id] - Unique ID\n     */\n    static loadSprite(url, id) {\n        return loadSprite(url, id);\n    }\n\n    /**\n     * Setup multiple instances\n     * @param {*} selector\n     * @param {Object} options\n     */\n    static setup(selector, options = {}) {\n        let targets = null;\n\n        if (is.string(selector)) {\n            targets = Array.from(document.querySelectorAll(selector));\n        } else if (is.nodeList(selector)) {\n            targets = Array.from(selector);\n        } else if (is.array(selector)) {\n            targets = selector.filter(is.element);\n        }\n\n        if (is.empty(targets)) {\n            return null;\n        }\n\n        return targets.map(t => new Plyr(t, options));\n    }\n}\n\nPlyr.defaults = cloneDeep(defaults);\n\nexport default Plyr;\n"],"sourceRoot":""}